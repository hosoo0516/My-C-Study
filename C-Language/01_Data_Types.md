#01. 자료형과 데이터의 표현

## 1. 기본 자료형 (Primitive Types)
- 정수형 : char, int, long
- 실수형 : float, double

1바이트 (Byte) = 8비트 (Bit)

|name|size|range|
|:---|:---|:---|
| char | 1byte | -128~127 |
|short int | 2bytes | -32768~32767 |
| int | 4bytes | -2147483648~2147483647 |
| long int | 4bytes | -2147483648~2147483647 |
| bool | 1byte | true or false |
| float | 4bytes | 소수점 7자리 |
| double | 8bytes | 소수점 15~16자리 |
| long double | 8bytes이상 | 소수점 18~19자리 |
<br><br>
### 왜 음수의 범위가 1 더 클까?
**이유:** 부모 비트가 '0'인 영역(양수)에 '0'이 포함되기 때문.<br>
**분포 (4비트 기준):**<br>
-양수 쪽: '0' ~ '7' (총 8개)
-음수 쪽: '-1' ~ '-8' (총 8개)<br>
**결론:** 0이 양수 형태를 하나 점유하면서, 자연스럽게 양수의 최댓값은 음수의 최솟값보다 절댓값이 1 작게 됨.<br>
**장점:** '-0'이라는 불필요한 값 없이 비트 조합을 알뜰하게 전부 사용함.<br>
<br>
### ⚠️ 정수 오버플로우 (Integer Overflow)
- **현상:** 자료형이 표현할 수 있는 최대 범위를 넘어서면 갑자기 최소값으로 되돌아가는 현상.
- **원인:** 부호 있는 정수(Signed)에서 최댓값(`0111...`)에 1을 더하면 부호 비트(MSB)가 1로 변하며 음수 영역의 최솟값으로 넘어가기 때문.
- **예시 (4비트 기준):** `7 (0111)` + `1` = `-8 (1000)`

## 2. 컴퓨터의 숫자 표현
### 2의 보수
**정의:** 음수를 표현하기 위해 사용하는 방법 <br>
**계산법:** 1의 보수(반전) + 1 <br>
**왜 쓰는가?** 가산기(Adder) 하나로 덧셈과 뺄셈을 모두 처리하기 위해서. <br>
<br>
**새로 알게 된 점**
<br>
"2의 보수를 사용하면 0을 중복 없이 하나로 표현할 수 있고(+0, -0), CPU회로에서 별도의 감산기 없이 덧셈만으로 뺄셈을 구현할 수 있어 경제적이다." <br>
맨 앞 비트가 부호비트라 생각(1이면 음수, 0이면 양수) <br>

```c
#include <stdio.h>

int main() {
	double a = 0.1 + 0.2;
	if (a == 0.3)
		printf("같음\n");
	else
		printf("다름 (결과값: %.20f)\n", a);
	return 0;
}
```

