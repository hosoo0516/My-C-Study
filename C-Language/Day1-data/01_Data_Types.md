#01. 자료형과 데이터의 표현

## 1. 기본 자료형 (Primitive Types)
- 정수형 : char, int, long
- 실수형 : float, double

1비트 (Bit) = 0 또는 1 <br>
1바이트 (Byte) = 8비트 (Bit) <br>
컴퓨터 메모리는 바이트 단위 주소 <br><br>

**같은 비트라도 해석 방법이 다르면 의미가 바뀐다.**
<br><br>
ex) 01000001 -> 65 -> 'A' <br>
<br>
**비트를 어떻게 해석할지 알려주기 위해서 자료형이 존재한다.** <br>
|name|size|range|
|:---|:---|:---|
| char | 1byte | -128~127 |
|short int | 2bytes | -32768~32767 |
| int | 4bytes | -2147483648~2147483647 |
| long int | 4bytes | -2147483648~2147483647 |
| bool | 1byte | true or false |
| float | 4bytes | 소수점 7자리 |
| double | 8bytes | 소수점 15~16자리 |
| long double | 8bytes이상 | 소수점 18~19자리 |
<br><br>
### 왜 음수의 범위가 1 더 클까?
**이유:** 부호 비트가 '0'인 영역(양수)에 '0'이 포함되기 때문.<br>
**분포 (4비트 기준):**<br>
-양수 쪽: '0' ~ '7' (총 8개)
-음수 쪽: '-1' ~ '-8' (총 8개)<br>
**결론:** 0이 양수 형태를 하나 점유하면서, 자연스럽게 양수의 최댓값은 음수의 최솟값보다 절댓값이 1 작게 됨.<br>
**장점:** '-0'이라는 불필요한 값 없이 비트 조합을 알뜰하게 전부 사용함.<br>
<br>
### 정수 오버플로우 (Integer Overflow)
- **현상:** 자료형이 표현할 수 있는 최대 범위를 넘어서면 갑자기 최소값으로 되돌아가는 현상.
- **원인:** 부호 있는 정수(Signed)에서 최댓값(`0111...`)에 1을 더하면 부호 비트(MSB)가 1로 변하며 음수 영역의 최솟값으로 넘어가기 때문.
- **예시 (4비트 기준):** `7 (0111)` + `1` = `-8 (1000)`

## 2. 컴퓨터의 숫자 표현
### 2의 보수 <br>
**정의:** 음수를 표현하기 위해 사용하는 방법 <br>
**계산법:** 1의 보수(반전) + 1 <br>
**왜 쓰는가?** 가산기(Adder) 하나로 덧셈과 뺄셈을 모두 처리하기 위해서. <br>
<br>
>**새로 알게 된 점**
<br>
"2의 보수를 사용하면 0을 중복 없이 하나로 표현할 수 있고(+0, -0), CPU회로에서 별도의 감산기 없이 덧셈만으로 뺄셈을 구현할 수 있어 경제적이다." <br>
맨 앞 비트가 부호비트라 생각(1이면 음수, 0이면 양수) <br>
<br>

## 3. 실수형의 한계와 정밀도

컴퓨터는 모든 숫자를 0과 1로 표현하기 때문에, 소수점 이하의 숫자를 표현할 때 **'부동 소수점(Floating Point)'** 방식을 사용한다. 이 방식은 효율적이지만 태생적인 한계가 있다.

### (1) 소수점 오차의 원인
컴퓨터는 1/2,  1/4,  1/8 처럼 2의 거듭제곱 역수로 소수점을 표현한다.  
이 때문에 $0.1$이나 $0.2$ 같은 10진수 소수를 2진수로 변환하면 **무한 소수**가 발생하며, 메모리 한계상 이를 중간에 잘라야(Rounding) 하므로 미세한 오차가 생긴다.

### (2) 정밀도(Precision) 차이
어느 정도까지 정확하게 표현할 수 있는지를 나타내는 척도이다.

| 자료형 | 크기 | 유효 자릿수 (정밀도) | 특징 |
| :--- | :---: | :---: | :--- |
| **`float`** | 4 byte | 약 7자리 | 적은 메모리 사용, 정밀도가 낮음 |
| **`double`** | 8 byte | 약 15~16자리 | C언어의 **기본 실수형**, 권장되는 방식 |

### (3) 컴공생의 주의사항
- **비교 연산의 위험성**: `if (0.1 + 0.2 == 0.3)`은 대부분 `false`가 나온다. 실수는 `==` 연산자로 직접 비교하는 대신, 두 값의 차이가 아주 작은 값(epsilon)보다 작은지 확인하는 방식을 써야 한다.
- **금융/정밀 계산**: 소수점 한 자리 오차가 큰 사고로 이어지는 분야에서는 실수형 대신 정수를 이용하거나 전용 라이브러리를 사용한다.

---
> **배운 점:** "실수는 '정확한 값'을 저장하는 것이 아니라 '가장 가까운 근삿값'을 저장하는 것이다."라는 점을 명심하자.
### 실습: 실수형 비교 테스트
- **파일명:** `float_precision_test.c`
- **코드 내용:** `0.1 + 0.2 == 0.3`이 참인지 확인
- **결과:** `다름 (결과값: 0.30000000000000004441)`
- **이유:** 부동 소수점 방식의 한계로 인해 미세한 오차(`0.0000...04441`)가 발생함.

```c
#include <stdio.h>

int main() {
	double a = 0.1 + 0.2;
	if (a == 0.3)
		printf("같음\n");
	else
		printf("다름 (결과값: %.20f)\n", a);
	return 0;
}
```
## 4. 비트 연산자 (Bitwise Operators)
데이터를 비트 단위로 조작할 때 사용한다. C언어에서 하드웨어를 제어하거나 성능을 최적화할 때 필수적이다.

| 연산자 | 기능 | 설명 |
| :---: | :--- | :--- |
| `&` | AND | 대응되는 비트가 모두 1이면 1 |
| `\|` | OR | 대응되는 비트 중 하나라도 1이면 1 |
| `^` | XOR | 대응되는 비트가 서로 다르면 1 |
| `~` | NOT | 비트를 반전 (0->1, 1->0) |
| `<<` | Left Shift | 비트를 왼쪽으로 이동 (2배 곱하기 효과) |
| `>>` | Right Shift | 비트를 오른쪽으로 이동 (2로 나누기 효과) |

>  `~n + 1`은 `-n`이 된다는 사실
