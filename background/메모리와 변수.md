## 1. 메모리는 그냥 "번호 붙은 칸들"이다.
<br>
메모리는 번호가 붙은 아주 많은 칸들의 집합<br>
<br>

| 주소 | | 값 |
| :--- | :---: | :--- |
| 0x1000 | → | ? |
| 0x1001 | → | ? |
| 0x1002 | → | ? |
| 0x1003 | → | ? |
| 0x1004 | → | ? |
| ... | | |

**각 칸은 1바이트(8비트)** <br>
**CPU는 이 주소로만 메모리에 접근한다.** <br>
<br>
### 그렇다면 1칸당 1바이트인데 더 작은 비트(Bit)라는 개념이 왜 필요할까?
<br>
결론부터 말하면, "컴퓨터는 바이트(Byte)라는 단위를 모르기 때문"이다.<br>
바이트(Byte)는 인간이 관리하기 편하려고 만든 '묶음 상품'이다.<br>
<br>
비트는 컴퓨터의 유일한 언어이다.<br>
1바이트라는 커다란 가방 안에 여러 개의 작은 정보를 구겨 넣고 싶을때 비트 단위 제어가 필요하다. <br>
<br>
예시) 게임 캐릭터의 상태 저장: 만약 비트 개념이 없다면 아래 정보 저장을 위해 메모리 8칸(8Byte)를 사용해야한다.<br>
1. 독에 중독됏는다? (YES/NO)<br>
2. 저주에 걸렸는가? (YES/NO)<br>
3. 불타고 있는가? (YES/NO)...(총 8개) <br>
<br>
하지만 비트 제어를 할 줄 알면, 메모리 딱 1칸(1Byte)에 이 8개의 정보를 다 넣을 수 있다.<br>
1. 독에 중독됏는다? (YES/NO)<br>
2. 저주에 걸렸는가? (YES/NO)<br>
3. 불타고 있는가? (YES/NO)...(총 8개) <br>

## 2. 변수 = 칸 + 크기 + 해석법
변수 = (시작 주소) + (몇 칸을 쓰는지) + (어떻게 읽을지)

### 예제 1: int a = 65;
**컴퓨터 내부에서 벌어지는 일**
1. 메모리 어딘가 비어 있는 칸을 찾음.
2. int니까 4바이트 필요(보통)
3. 연속된 4칸을 할당 <br> <br>

| 주소 | | 값 |
| :--- | :---: | :--- |
| 0x2000 | → | 41 |
| 0x2001 | → | 00 |
| 0x2002 | → | 00 |
| 0x2003 | → | 00 |

<br> -> 컴퓨터는 스스로 메모리에 41(16진수)를 보고 이게 숫자인지, 문자인지, 4바이트 중 일부인지 알지 못한다. <br>
  우리가 작성한 '자료형(int,char)'을 보고 컴파일러가 판단하여 CPU에게 명령을 내린다.
  
  > ### 💡 한 문장 요약
> 데이터는 메모리에 **16진수(`41`)** 형태로 똑같이 저장되지만, **자료형(컴파일러)**이 CPU에게 내리는 **명령어**에 따라 **65(숫자)**가 될 수도, **'A'(문자)**가 될 수도 있다!
